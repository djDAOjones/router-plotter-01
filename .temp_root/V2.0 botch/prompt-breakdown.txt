# Prompts to break up v2 development

Use these in order. Each prompt targets a focused, runnable deliverable. Keep the deterministic runtime as the shared contract between preview and export.

## Recommended AI model per prompt

- **SWE-1.5 (Cascade)**: Best for code-heavy, stepwise implementation, scaffolding, geometry/timing math, Canvas/IndexedDB/MediaRecorder, and rapid iteration.
- **Claude Opus 4.1 (thinking)**: Best for architecture, schema design, API contracts, complex constraints, a11y/UX planning, and research/comparisons.
- **ChatGPT 5.1 (high reasoning)**: Good for planning and architecture; may need more prompting to output runnable code in chunks. Use when you want thorough reasoning before implementation.

---

## 1. Scaffold project and core types

> Prompt: Scaffold a TypeScript + Vite project with Canvas 2D, IndexedDB, and JSZip. Define core types for project schema (schemaVersion, meta, a11y, assets, settings, tracks), waypoint (major/minor), timing modes (constantTime, constantSpeed), pause modes (none/seconds/click), and track types (path, camera, labels). Add a package.json with vite, typescript, @types/node, jszip, zod for schema validation. Set up src/ folders: core/, engine/, renderer/, ui/, persistence/, export/, types/. Export a minimal ProjectSchema type and a default empty project object.
>
> **Recommended model**: Claude Haiku (fast scaffolding and boilerplate) or SWE-1.5 (if you want runnable code in one pass).

---

## 2. Geometry engine: centripetal Catmull-Rom and arc-length LUT

> Prompt: Implement a geometry module in src/engine/geometry.ts with centripetal Catmull-Rom interpolation (tension ~0.5) and arc-length precomputation. Functions: catmullRomCentripetal(p0,p1,p2,p3,t) returning {x,y}, buildArcLengthTable(points) returning cumulative distances, and getPositionAtArcLength(points, distances, targetLength). Add a simple test that creates a 4-point path, builds the table, and queries positions at several lengths with expected tolerance.
>
> **Recommended model**: SWE-1.5 (code-heavy, precise math, tests).

---

## 3. Timing and easing engine

> Prompt: Create src/engine/timing.ts with timing modes: constantTimePerSegment (major→major) and constantSpeed (arc-length). Implement a SegmentTimingMap that stores per-segment durations, total duration, and a getTimeAtNormalizedProgress(t) mapping. Add easing: quadratic ease in/out between majors when pause modes are enabled. Include a function to rebuild the timing map when majors or timing mode changes. Unit test with 3 majors and both timing modes.
>
> **Recommended model**: SWE-1.5 (code-heavy, timing math, tests).

---

## 4. Deterministic runtime clock

> Prompt: Build a deterministic runtime in src/engine/runtime.ts with a fixed-step clock (dt = 1/fps). It should expose: step(), seekToTime(t), seekToNormalizedProgress(u), getCurrentState() with time, normalizedProgress, and currentSegmentIndex. Support play/pause and speed multipliers for preview. Export a simple demo that steps through a 3-major path and logs normalized progress at each step.
>
> **Recommended model**: SWE-1.5 (code-heavy, runtime logic, demo).

---

## 5. Renderer layers and base drawing

> Prompt: Implement a layered Canvas 2D renderer in src/renderer/canvasRenderer.ts. Layers: base image, contrast overlay (black↔none↔white), mask/unmask (basic), vectors (paths/labels/head). Provide drawFrame(state) that clears and draws layers in order. Add a ContrastOverlay utility to apply a full-screen overlay with a linear slider value. Include a simple demo that draws a static path with a contrast overlay.
>
> **Recommended model**: SWE-1.5 (Canvas 2D, layering, demo).

---

## 6. Path and waypoint drawing styles

> Prompt: Extend the renderer with path styles: line, dashed, dots, squiggle (periodic perturbation). Waypoint shapes: circle, square, nothing. Path head: arrow, pulsing dot, custom image with rotation offset. Add style objects to PathTrack and use them in drawFrame. Provide a demo page with controls to switch styles and redraw.
>
> **Recommended model**: SWE-1.5 (Canvas styles, UI controls, demo).

---

## 7. Camera transform with bounds and safety margin

> Prompt: Add camera support in src/renderer/camera.ts. Given a path position and optional zoom, compute a view matrix that centers the point with a safety margin pct and respects image bounds. Provide applyCameraTransform(ctx, cameraState) and a demo that animates a camera following a short path with zoom changes.
>
> **Recommended model**: SWE-1.5 (Canvas transforms, math, demo).

---

## 8. Authoring UI: track tabs and waypoint editing

> Prompt: Build an authoring UI in src/ui/authoringPanel.ts with tabs for path, camera, and labels. Implement click-to-add waypoints, drag-to-adjust, major/minor toggle, and a reorderable list of majors with delete. Add keyboard: arrow nudge ±1% (Shift 5%), Esc to cancel drag, Space play/pause, J/K/L transport (speeds 0.25–8x). Wire this to the geometry engine to update paths live.
>
> **Recommended model**: SWE-1.5 (UI components, event handling, keyboard).

---

## 9. Preview controls: 200-step slider and playback

> Prompt: Create a preview control bar in src/ui/previewControls.ts with play/pause, start/end buttons, and a 200-step slider that maps to normalizedProgress. Connect it to the deterministic runtime and renderer so scrubbing redraws the correct frame. Display current time and step number. Include a demo with a short path that can be scrubbed smoothly.
>
> **Recommended model**: SWE-1.5 (UI controls, runtime integration, demo).

---

## 10. Autosave and undo/redo with IndexedDB

> Prompt: Implement persistence in src/persistence/autosave.ts using IndexedDB. Store the full project JSON and a command stack for undo/redo (>=100). Throttle autosave on changes (idle or 2 s). Provide functions: saveProject(project), loadProject(id), undo(), redo(), getSaveList(). Add a simple UI to list saves and load/delete.
>
> **Recommended model**: SWE-1.5 (IndexedDB, command pattern, UI).

---

## 11. Import/export zip with assets

> Prompt: Add src/persistence/projectZip.ts to import/export a zip containing project.json and an assets/ folder. Use JSZip to read/write. On export, embed assets by path; on import, load assets into IndexedDB and update asset IDs. Include validation that required alt text is present and asset sizes/caps are respected. Provide UI buttons to export/import zip files.
>
> **Recommended model**: SWE-1.5 (JSZip, file handling, validation, UI).

---

## 12. Export pipeline: WebM via captureStream and PNG sequence fallback

> Prompt: Build an export pipeline in src/export/videoExport.ts. Use the deterministic runtime at 25 fps to drive the renderer. For WebM, use canvas.captureStream(25) and MediaRecorder. For PNG sequence fallback, render frames to Blobs and zip them. Include pre-roll (1 s) and post-roll (3 s). Honor pause modes and reduced motion. Provide UI to select format and start export, with progress feedback.
>
> **Recommended model**: SWE-1.5 (MediaRecorder, captureStream, fixed-step export, UI).

---

## 13. Validation and caps enforcement

> Prompt: Create src/validation/projectValidator.ts to enforce: alt text required, monotonic segment times, asset size caps (≤10 MB each, total ≤100 MB), path points ≤1,000 per path, majors ≤100, labels ≤200, export duration ≤90 s. Block export with clear, actionable error messages. Add a “Validate Project” button in the UI that lists any issues.
>
> **Recommended model**: Claude Opus 4.1 (complex constraint design, error messages) then SWE-1.5 (implementation).

---

## 14. Accessibility: reduced motion, focus, touch targets, palettes

> Prompt: Implement accessibility utilities in src/a11y/a11y.ts. Replace pans/zooms with fades when reduced motion is set. Ensure touch targets ≥44 px. Manage focus for keyboard navigation. Provide 2–3 colorblind-safe palettes (OkLCH-based) and a palette switcher. Add a checkbox for reduced motion and update the renderer accordingly.
>
> **Recommended model**: Claude Opus 4.1 (a11y strategy, palette design) then SWE-1.5 (implementation).

---

## 15. Embed API: postMessage commands and events

> Prompt: Add an embed API in src/embed/api.ts. Accept postMessage commands: play, pause, seekToStep(number), setSpeed(number). Send events: ready, state({step, playing, speed}), ended. Include origin checking and error responses. Provide a minimal demo page that embeds the app in an iframe and controls it via postMessage.
>
> **Recommended model**: Claude Opus 4.1 (API contract design, edge cases) then SWE-1.5 (implementation).

---

## 16. End-to-end testing and docs

> Prompt: Write end-to-end tests for a round-trip: create project, add path/camera/labels, save, export WebM, import zip, and validate parity between preview and export frames (±1 frame tolerance). Create user docs: quick start, embed guide, export guide, and schema reference. Update README.md with setup and usage instructions.
>
> **Recommended model**: Claude Opus 4.1 (test plan, doc outlines) then SWE-1.5 (test code, markdown).

---

# Optional follow-ons (v2.1 backlog)

- Label collision avoidance (anchor candidates + staggering)
- Hotspot pattern presets
- Transparent overlay export (PNG alpha sequence)

---

# How to use

- Run prompts in order. Each should result in runnable code/tests.
- Keep the deterministic runtime as the source of truth for both preview and export.
- After each prompt, commit and tag the milestone (e.g., git tag v2.0-01-scaffold).

---

# Notes

- Export–preview parity target: ±1 frame (~40 ms @ 25 fps) in v2.0.
- Caps: path points ≤1,000; majors ≤100; labels ≤200; export duration ≤90 s; assets ≤10 MB each, total ≤100 MB.
- Accessibility baseline: alt text required; reduced motion fallback; touch targets ≥44 px; palette presets (2–3 colorblind-safe).
- Embed API (v2.0): commands play/pause/seekToStep/setSpeed; events ready/state/ended.
- Validation blocks export on failure with clear messages.
